# Juice

Juice는 90년대 Elf와 Silky's 게임에서 사용하였던 MES 스크립트를 해석해주는 도구입니다. MES 바이트코드를 텍스트 소스로 변환하고, 이렇게 해석된 소스를 수정한 다음 다시 바이트코드로 컴파일 가능합니다. 대사를 비롯한 게임 로직을 마음대로 바꾸어줄 수 있기 때문에 한국어 혹은 그외의 언어로 번역 패치를 만드는 데에 유용합니다. 현재 AI5 엔진에 대응하고 있으며, 코드가 호환되는 AI4 엔진의 스크립트에도 적용할 수 있습니다.

## 사용방법

1. 디컴파일 (decompile)

현재 디렉토리의 .MES 스크립트 전부를 디컴파일링하기 위해서,

```
$ ./juice -d *.MES
```

이렇게 입력하면 MES.rkt 확장자를 가진 텍스트 소스가 생성됩니다.

2. 컴파일 (compile)

소스를 컴파일하기 위해서는,

```
$ ./juice -c *.MES.rkt
```

이렇게 입력하면 MES.rkt.mes 확장자를 가진 스크립트가 생성됩니다. 예를 들어, `START.MES`를 디컴파일하여 생성된 `START.MES.rkt`를 다시 컴파일하면 `START.MES.rkt.mes` 스크립트가 만들어집니다. 이렇게 만들어진 스크립트는 원칙적으로 원본 스크립트와 동일해야 합니다. macOS에서는 `cmp`, Windows에서는 `fc` 명령어를 이용하여 비교할 수 있습니다.

```
$ cmp START.MES START.MES.rkt.mes
```

이렇게 비교해서 아무런 오류가 나오지 않는다면 제대로 변환이 된 것입니다. 간혹 일부 차이가 발생하는 것은 원본 게임에서 대사 압축이 누락되었거나 파일 끝부분에 불필요한 코드가 남아있는 등의 경우가 대부분입니다. 코드를 좀 더 들여다보면 마지막 else 구문이 비어 있을 때 코드가 조금 달라지는 경우도 있습닏나. 아마 게임 로직 자체에는 영향이 없을 것이라고 생각됩니다만, 확실치 않다면 직접 테스트해서 확인해보는 것이 안전하겠습니다. 혹시 문제가 있다면 알려주세요.

3. 반복제거 (deduplication)

어떤 게임들은 MES 파일에 공통 코드가 반복되어 있기도 합니다. 대부분 파일의 앞부분에 위치하고 있으며 함수 선언 (`define-proc`) 목록인 경우가 많습니다. 일부 함수들은 메뉴 등에서 대사를 표시하는 용도로 사용하기 때문에 번역을 위해서는 모든 파일을 일일이 수정해야 하는 번거로움이 있습니다. 이런 수고를 덜어주기 위해 반복제거 기능을 이용하면 공통적으로 사용된 함수 선언 코드를 `_proc_NN_xxxxxxxxxxxxxxxx.rkt`와 같은 이름의 외부 코드로 추출할 수 있습니다. 이 경우 기존 소스에서 사용하던 `define-proc`은 `include` 구문이 대체합니다.

```
$ ./juice -D *.MES.rkt
```

이렇게 한번 더 처리된 소스를 컴파일하기 위해서는 `juice -c *.MES.rkt.rkt`와 같이 실행하면 됩니다. 확장자에 주의하세요. 생성된 MES.rkt.rkt.mes 파일은 반복제거를 하지 않고 생성하였던 MES.rkt.mes 파일, 그리고 원본 MES 파일과 동일해야 합니다.

## 옵션

`juice -h`를 실행하면 명령 및 옵션에 대해 좀 더 상세한 설명을 볼 수 있습니다.

- `--version`, `-v` : 버전 표시
- `--force`, `-f` : 파일 생성시 기존 파일 덮어 씌우기
- `--charset <c>` : 문자집합 인코딩 지정 (**pc98**, europe, korean-..)
- `--dictbase <b>` : 대사 압축용 사전의 기준 인덱스 (**80**, D0)
- `--extraop` : 일부 게임에서 사용하는 비표준 실행코드 지원
- `--no-decode` : *(디컴파일)* SJIS 문자 디코딩 하지 않기
- `--no-resolve` : *(디컴파일* cmd/sys 명령에 이름 붙이지 않기
- `--no-protag` : *(디컴파일)* 이름 표시용 proc/call을 대사에 합치지 않기
- `--wordwrap <w>` : *(컴파일)* 대사 자동 줄바꿈 기준 길이
- `--no-compress` : *(컴파일)* 대사 압축하지 않기

## 안내

### 작업순서

대개의 게임들은 특별한 옵션 지정 없이 작업 가능합니다. 동급생 1/2, 드래곤 나이트 3/4 등이 해당합니다.

```
juice -df *.MES
juice -Df *.MES.rkt
juice -cf *.MES.rkt.rkt
```

### 사전 (dictionary)

사전은 대사에 공통적으로 등장하는 문자들을 뽑아서 저장해놓은 테이블입니다. 사전에 등록된 문자는 1 바이트의 인덱스로 표현할 수 있기 때문에 일반적인 2 바이트 SJIS 코드만 사용할 때와 비교하여 스크립트 파일의 크기를 상당히 줄일 수 있습니다. 이러한 사전 구조체는 MES 파일의 가장 앞부분에 위치합니다. rkt 소스 코드에서는 `meta` 섹션 내 `(dict ..)` 구문으로 사전을 정의합니다.

```racket
(meta
  (dict #\u3000 #\【 #\】 ..))
```

대사를 번역한 경우에는 사전도 그에 맞춰 바꾸어 주어야 할텐데요. 이때는 위의 `(dict ..)` 구문을 `(dict-build)`로 수정하면 컴파일 과정에서 사전이 자동으로 만들어지게 됩니다.

```racket
(meta
  (dict-build))
```

후반기에 출시된 일부 게임들은 확장 SJIS 코드를 사용하기 위해 사전의 기준 인덱스가 바뀌었고 그 결과 사전 크기도 줄어들게 되었습니다. `--dictbase` 옵션을 이용하여 두가지 기준 인덱스 중 하나를 선택하세요; 대부분 초반 게임들은 `80` (128)을 사용하며 이후 출시된 Jack, 유작, 하급생, 유노 등은 `D0` (208)으로 하면 됩니다. 만약 `0xD0`으로 해야되는 게임에서 실수로 옵션을 누락하면 "list-ref: index too large for list"와 같은 오류가 나옵니다. 디컴파일 할 때 사용하였던 `dictbase` 값은 소스 코드의 `meta` 섹션에 저장되기 때문에 컴파일 할 때 다시 지정해주어야 할 필요는 없습니다.

```
juice -df --dictbase D0 *.MES
juice -Df *.MES.rkt
juice -cf *.MES.rkt.rkt
```

### 호환성

초창기에는 게임마다 적용된 AI5 엔진에 비록 차이가 있더라도 스크립트 파일의 전반적인 바이트코드 구조 자체는 크게 다르지 않았습니다. 하지만 후반기에 들어 이러한 규칙이 깨지고 기존의 문법과 호환되지 않는 코드가 일부 등장하게 되었는데요. 이를 구분해주기 위해서 유작이나 유노 같은 게임에는 `-extraop` 옵션을 넣어주어야 합니다. 이 정보 역시 `meta` 섹션에 기록되므로 디컴파일링 이후 단계에서는 다시 지정해줄 필요는 없습니다.

```
juice -df --dictbase D0 --extraop *.MES
juice -Df *.MES.rkt
juice -cf *.MES.rkt.rkt
```

### 대사 (text)

대사 문자열은 `(text ..)` 구문 속에 들어갑니다.

```racket
(text "【景】こんにちは。")
```

`(text ..)` 구문에는 여러 문자열이 들어갈 수도 있고 숫자나 다른 기호가 등장할 수도 있습니다.

```racket
(text "【"0"】こんにちは。")
```

여기서 두 문자열 사이의 숫자 0은 `(proc 0)` 함수 호출 구문을 의미합니다. 0번 함수는 대개 주인공 이름을 지정할 수 있는 게임에서 해당 이름을 표시하기 위해 사용합니다. 이러한 함수 번호는 게임마다 다를 수 있습니다. 예를 들어 하급생은 `(proc 3`)을 사용하고 Elle에서는 `(call Z)`이 사용됩니다. 상기 예제는 컴파일 과정에서 아래와 같이 세개의 독립적인 구문으로 분해됩니다.

```racket
(text "【")
(proc 0)
(text "】こんにちは。")
```

동급생 1 같은 일부 게임에서는 각 대사 줄마다 매번 색상 변경 구문이 함께 등장하는데요.

```racket
(text-color 7)
(text "【" 0 "】こんにちは。")
```

디컴파일 과정에서는 이러한 패턴을 파악하여 `#:color` 키워드를 사용하는 간소한 문법으로 변환해줍니다.

```racket
(text #:color 7 "【"0"】こんにちは。")
```

번역을 하는 경우에는 `(text ..)` 구문 내의 문자열을 직접 바꿔주면 됩니다.

```racket
(text "["0"] Hello.")
```

이렇게 대사에서 사용할 수 있는 문자집합은 다음에 설명할 `(charset ..)`으로 정의하는 것을 따릅니다. 문자집합을 변경하는 것만으로 한국어, 영어, 혹은 그외의 여러가지 언어에 대응하는 번역 작업을 진행할 수 있습니다.

```racket
(text "["0"] 안녕.")
```

```racket
(text "["0"] Allô.") ; 프랑스어 예제
```

참고로 코드에서 `;` 다음에 나오는 글자들은 모두 주석으로 처리되니 필요할 때 사용하세요.

### 문자집합 (charset)

기본적으로 원본 일본어 스크립트에서 사용되는 문자들은 `pc98`이라는 이름의 문자집합으로 정의합니다. 해당 문자집합은 Shift JIS 인코딩에 기반하고 있지만 PC-98 전용으로 사용되던 문자열이 12, 13구에 추가 할당되어 있습니다. 예를 들어 Foxy 2에서 제목을 표시하기 위해 등장하는 `Ⅱ`와 같은 문자는 요즘 사용되는 SJIS 문자와는 코드가 다릅니다.

소스 파일은 UTF-8으로 인코딩합니다. 컴파일 과정에서는 `(text ..)` 내에서 사용된 UTF-8 문자와 이것이 의미하는 Shift JIS 코드 간의 변환 규칙이 필요한데요. 각 문자를 해석할 때는 앞서 언급한 비표준 코드를 처리할 수 있도록 먼저 사용자 지정 문자집합 내에 정의되어 있는지 확인합니다. 만약에 정의되지 않은 문자라면 일반적인 변환 과정을 거치게 됩니다.

예를 들어, 위의 `Ⅱ`는 `pc98` 문자집합 내에 JIS 코드 포인트 (13, 22)로 정의되어 있습니다. 해당 코드는 SJIS 바이트 (0x87 0x55)에 해당합니다. 이러한 사용자 정의 규칙 없이 일반적인 SJIS 인코더 만으로는 JIS X 0208 표준에 포함되어 있지 않은 `Ⅱ`를 변환할 수가 없었을 것입니다. 참고로 이후 개장된 JIS X 0213 문자집합 표준에서는 `Ⅱ`를 비롯한 일부 NEC 전용 문자를 포함하게 되었지만, 여전히 (그리고 앞으로도) 우리가 사용하려는 원래의 PC-98 문자집합과 온전히 호환되지는 않습니다.

이와 더불어, 적절한 사용자 지정 문자집합을 넣어주는 것으로써 일본어가 아닌 문자로 만들어진 폰트에 쉽게 대응할 수 있습니다. 예를 들어 이미 많이 접해보셨을 한글 음절이 포함된 폰트라든지, 프랑스어 발음 구별 기호가 들어간 폰트를 만들어 각 언어에 대응하는 번역의 진행이 가능합니다. 소스 코드에서 사용할 문자집합은 `(meta ..)` 섹션 내에 지정할 수 있습니다.

```racket
(meta
  (charset "english"))
```

`(charset ..)`은 외부 파일에 정의되어 있는 문자집합을 불러올 수 있습니다. 현재 기본적으로 함께 배포되는 문자집합은 다음과 같습니다.

- `pc98`: 기본 SJIS 인코딩에 NEC PC-98 전용 문자 일부를 12, 13구에 추가.
- `english`: `pc98` 기반으로 ASCII 문자를 9구(NEC PC-98 반각문자)에 할당. 사용자 폰트 필요 없음.
- `europe`: `pc98` 기반으로 발음 구별 기호가 포함된 알파벳을 48, 49구에 추가. 사용자 폰트 필요.
- `korean-kk`: `pc98` 기반으로 한글 음절을 19구에서 부터 할당. K.K님이 작업하신 샹그리라 2, Jack, Elle, 유노, edenrock님이 작업하신 실낙원, 드래곤 나이트 4, 샹그리라 1 등에 대응.
- `korean-hannuri`: `pc98` 기반으로 비표준 SJIS 코드를 이용한 한글 음절 할당. 한누리의 동급생 1/2 한글화에 대응.
- `korean-gamebox`: 비표준 SJIS 코드를 이용하고, 완성형보다 많은 한글 지원. 동급생 2 정식발매판에 대응.

필요하다면 "_charset_chinese.rkt"과 같은 이름의 문자집합 정의 파일을 직접 만들어 사용할 수도 있습니다. 해당 파일에서는 여러가지 문자집합 관련 구문을 사용할 수 있습니다. 예를 들어, 영어 지원을 위해 내장된 "_charset_english.rkt"는 다음과 같습니다.

```racket
(charset "pc98")
(charset* 9 1
 #\! #\" #\# #\$ #\% #\& #\' #\( #\) #\* #\+ #\, #\- #\. #\/
 #\0 #\1 #\2 #\3 #\4 #\5 #\6 #\7 #\8 #\9
 #\: #\; #\< #\= #\> #\? #\@
 #\A #\B #\C #\D #\E #\F #\G #\H #\I #\J #\K #\L #\M #\N #\O #\P #\Q #\R #\S #\T #\U #\V #\W #\X #\Y #\Z
 #\[ #\\ #\] #\^ #\_ #\`
 #\a #\b #\c #\d #\e #\f #\g #\h #\i #\j #\k #\l #\m #\n #\o #\p #\q #\r #\s #\t #\u #\v #\w #\x #\y #\z
 #\{ #\| #\} #\~)
(fontwidth 1)
(charspc #\ )
```

첫번째 줄의 `(charset ..)`은 기존 문자집합을 불러들이는 구문입니다. 다음 줄의 `(charset* k t c ..)`는 `c ..`에 나열된 문자들을 `r` 구 `t` 점에서 시작하는 JIS 코드 포인트로 할당합니다. JIS 코드 포인트는 (행, 열) 혹은 (구, 점)으로써 폰트 공간 내의 특정 위치를 지정합니다. 에뮬레이터 기준으로는 ANEX86.BMP나 FREECG98.BMP와 같은 폰트 이미지 내의 위치라고 볼 수도 있습니다. 예를 들어, `english` 문자집합의 `!` 문자는 JIS 코드 포인트 (9, 1)으로 정의되며 이는 SJIS 바이트 (0x85 0x40)가 되어 기록됩니다. 참고로 SJIS 인코딩에는 비슷하게 생겼지만 다른 코드를 가지는 ASCII 문자들이 포함되어 있습니다. 전각문자 `！`(0x81 0x49)는 일반적인 `!`(0x21)와는 다른 식이죠. `(text ..)` 내의 대사를 번역할 때에는 이러한 차이를 감안하여 일관되게 작업을 진행하는 것이 좋겠습니다.

기존 MES 스크립트 파일을 특정 문자집합 기준으로 분해하기 위해서는 `--charset` 옵션을 사용합니다.

```
juice -df --charset korean-kk *.MES
```

### 폰트 너비

원본 게임에서는 대부분의 경우 한 글자가 전각문자(full-width) 기준의 너비, 다시 말하면 반각문자의 두배 가로폭(double space)을 가지는 것을 기준으로 합니다. 이는 영문 등 서양 언어를 대상으로 하는 번역의 경우에 글자 폭이 너무 넓어져 거슬리는 부분이 됩니다. 한글에서도 글자 사이의 공백이 넓어 어색해보이는 부분이 없는 것은 아니기 때문에 예전 한누리 패치에서는 이를 별도 처리하기도 하였습니다. 번역된 게임의 대사에서 반각문자(half-width) 기준의 좁은 가로폭(single space)을 지원하기 위해서는 스크립트 내 일부 코드를 수정할 수도 있습니다. 대개의 게임에서는 폰트 너비를 설정할 때 아래와 유사한 코드를 사용합니다.

```racket
(set-arr~ @ 21 (+ 512 16))
```

`@`은 시스템 변수를 저장하는 배열의 이름입니다. 각 시스템 변수는 2 바이트, 혹은 1 워드의 크기를 가집니다. 여기서 `21`번째 변수에는 폰트 너비와 높이가 설정되어 있습니다. 첫번째 바이트는 폰트 높이를 픽셀 단위로, 두번째 바이트는 폰트 너비를 8 픽셀 가로폭의 "글자" 수 단위로 지정합니다. 위의 예제에서 `16`은 폰트 높이, `512`(= 2 << 8)는 폰트 너비가 되는 식이죠. 폰트 너비 `2`는 두배 가로폭을 의미합니다. 좁은 가로폭을 설정하기 위해서는 이 숫자 `2`를 `1`로 바꿔주면 되는 식이죠.

```racket
;; set up narrow spacing
;; 272 = 256 + 16 = (1 << 8) + 16
(set-arr~ @ 21 272)
```

실제 적용을 위해서는 위와 같은 설정 코드를 대사 등장 직전에 넣어주면 됩니다. 각 문단 마지막에서는 원래 설정으로 되돌려 주는 것이 좋겠지요.

```racket
;; back to wide spacing
;; 528 = 512 + 16 = (2 << 8) + 16
(set-arr~ @ 21 528)
```

원본 스크립트를 살펴보면 대개 이러한 폰트 설정 코드가 매 장면마다 호출되는 것을 볼 수 있습니다. 이러한 코드를 공통 함수로 정의하여 다른 파일에 저장해놓은 경우도 있습니다. 원본 스크립트의 수정을 최소화하면서 작업을 진행하기 위해서는 `START1.MES`와 같은 공통 파일들부터 차근차근 정리하는 것이 좋겠습니다. 이러한 작업을 진행할 때에는 Git과 같은 버전 관리 도구를 활용하여 수정된 부분을 명확히 기록해놓을 것을 추천합니다.

### 줄바꿈 (word wrap)

길이가 긴 대사는 화면 속의 대사창에서 여러 줄에 나뉘어 표시되어야 하는 경우가 많습니다. 원본 게임의 일본어 기준으로는 공백이 없기 때문에 별도로 줄바꿈 처리를 하지 않는 경우가 대부분이지만, 한글이나 특히 영어권 문자에서는 민감하게 다뤄지는 문제입니다. 예를 들어 가상의 프랑스어 대사를 살펴보겠습니다.

```racket
(text "[Me] Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris lobortis est id.")
```

동급생 1을 기준으로 하면 대사창의 폭이 반각문자 50개로 정해져 있기 때문에 해당 대사는 아래와 같이 표시됩니다.

```
[Me] Lorem ipsum dolor sit amet, consectetur adipi
scing elit. Mauris lobortis est id.
```

첫번째 줄 마지막 단어가 중간에 끊어져 버립니다. 온전한 줄바꿈을 위해서는 그 앞 단어 뒤에 공백을 더 추가해줄 수 있습니다.

```racket
(text "[Me] Lorem ipsum dolor sit amet, consectetur      adipiscing elit. Mauris lobortis est id.")
```

그러면 아래와 같이 깔끔한 줄바꿈이 됩니다.

```
[Me] Lorem ipsum dolor sit amet, consectetur
adipiscing elit. Mauris lobortis est id.
```

이렇게 수동으로 공백을 넣어주는 대신 `(text ..)` 구문에서는 `#:wrap` 키워드를 이용하여 추가 공백을 자동으로 넣어줄 수 있습니다.

```racket
(text "[Me] Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris lobortis est id." #:wrap 50)
```

이러한 줄바꿈을 스크립트 전체에 자동으로 적용하기 위해서는 컴파일을 할 때 `--wordwrap` 옵션으로 지정해줄 수도 있습니다.

```racket
juice -c --wordwrap 50 *.MES.rkt
```

조금 더 편리하게는 `(meta ..)` 섹션 내에 `(wordwrap ..)` 구문을 넣어주는 방법도 있습니다.

```racket
(meta
  (wordwrap 50))
```

각 게임마다 사용하는 대사창의 크기가 다르기 때문에 실제 줄바꿈 기준 값은 직접 확인해보아야 합니다. 같은 게임 내에서도 장면에 따라 대사창의 크기가 달라질 수 있습니다. 만약 자동 줄바꿈이 적용된 상황에서 특정 대사는 제외하고 싶다면 길이 대신에 `#f`(false) 값을 넣어주면 됩니다.

```racket
(text "Lorem ipsum dolor sit amet, consectetur adipiscing elit. Mauris lobortis est id." #:wrap #f)
```

### 편집기

소스 코드에서 사용하는 문법은 Racket이라는 언어를 따르고 있습니다. 편집기에서 Racket 전용 (rkt 확장자) 문법 강조 플러그인을 사용한다면 코드를 알아보기가 훨씬 수월해집니다. 덤으로 자잘한 문법 오류들은 눈으로 직접 확인이 가능해지기도 합니다. 만약 사용하는 편집기가 Racket을 지원하지 않는다면 Scheme이나 Lisp용을 대신 사용하여도 무방합니다.

## 연락처

질문이 있으시면 네이버 한식구 카페의 해당 게시물을 이용해주시기 바랍니다. 참고로 현재까지 본 도구에 대한 논의 및 번역 작업 진행은 PC-9800 Series Central 디스코드의 #pc-98_translation_discussion 채널에서 주로 진행되어 왔습니다.

마지막 수정: 2021-06-23
